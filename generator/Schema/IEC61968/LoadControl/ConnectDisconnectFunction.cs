//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using TTC2017.SmartGrids.CIM;
using TTC2017.SmartGrids.CIM.IEC61968.Metering;
using TTC2017.SmartGrids.CIM.IEC61970.Wires;

namespace TTC2017.SmartGrids.CIM.IEC61968.LoadControl
{
    
    
    /// <summary>
    /// The default implementation of the ConnectDisconnectFunction class
    /// </summary>
    [XmlNamespaceAttribute("http://iec.ch/TC57/2009/CIM-schema-cim14#LoadControl")]
    [XmlNamespacePrefixAttribute("cimLoadControl")]
    [ModelRepresentationClassAttribute("http://iec.ch/TC57/2009/CIM-schema-cim14#//IEC61968/LoadControl/ConnectDisconnect" +
        "Function")]
    [DebuggerDisplayAttribute("ConnectDisconnectFunction {UUID}")]
    public partial class ConnectDisconnectFunction : DeviceFunction, IConnectDisconnectFunction, IModelElement
    {
        
        /// <summary>
        /// The backing field for the IsDelayedDiscon property
        /// </summary>
        private bool _isDelayedDiscon;
        
        private static Lazy<ITypedElement> _isDelayedDisconAttribute = new Lazy<ITypedElement>(RetrieveIsDelayedDisconAttribute);
        
        /// <summary>
        /// The backing field for the IsLocalAutoReconOp property
        /// </summary>
        private bool _isLocalAutoReconOp;
        
        private static Lazy<ITypedElement> _isLocalAutoReconOpAttribute = new Lazy<ITypedElement>(RetrieveIsLocalAutoReconOpAttribute);
        
        /// <summary>
        /// The backing field for the IsLocalAutoDisconOp property
        /// </summary>
        private bool _isLocalAutoDisconOp;
        
        private static Lazy<ITypedElement> _isLocalAutoDisconOpAttribute = new Lazy<ITypedElement>(RetrieveIsLocalAutoDisconOpAttribute);
        
        /// <summary>
        /// The backing field for the IsConnected property
        /// </summary>
        private bool _isConnected;
        
        private static Lazy<ITypedElement> _isConnectedAttribute = new Lazy<ITypedElement>(RetrieveIsConnectedAttribute);
        
        /// <summary>
        /// The backing field for the IsRemoteAutoDisconOp property
        /// </summary>
        private bool _isRemoteAutoDisconOp;
        
        private static Lazy<ITypedElement> _isRemoteAutoDisconOpAttribute = new Lazy<ITypedElement>(RetrieveIsRemoteAutoDisconOpAttribute);
        
        /// <summary>
        /// The backing field for the EventCount property
        /// </summary>
        private int _eventCount;
        
        private static Lazy<ITypedElement> _eventCountAttribute = new Lazy<ITypedElement>(RetrieveEventCountAttribute);
        
        /// <summary>
        /// The backing field for the IsRemoteAutoReconOp property
        /// </summary>
        private bool _isRemoteAutoReconOp;
        
        private static Lazy<ITypedElement> _isRemoteAutoReconOpAttribute = new Lazy<ITypedElement>(RetrieveIsRemoteAutoReconOpAttribute);
        
        private static Lazy<ITypedElement> _switchesReference = new Lazy<ITypedElement>(RetrieveSwitchesReference);
        
        /// <summary>
        /// The backing field for the Switches property
        /// </summary>
        private ConnectDisconnectFunctionSwitchesCollection _switches;
        
        private static Lazy<ITypedElement> _rcdInfoReference = new Lazy<ITypedElement>(RetrieveRcdInfoReference);
        
        /// <summary>
        /// The backing field for the RcdInfo property
        /// </summary>
        private IRemoteConnectDisconnectInfo _rcdInfo;
        
        private static IClass _classInstance;
        
        public ConnectDisconnectFunction()
        {
            this._switches = new ConnectDisconnectFunctionSwitchesCollection(this);
            this._switches.CollectionChanging += this.SwitchesCollectionChanging;
            this._switches.CollectionChanged += this.SwitchesCollectionChanged;
        }
        
        /// <summary>
        /// The isDelayedDiscon property
        /// </summary>
        [XmlElementNameAttribute("isDelayedDiscon")]
        [XmlAttributeAttribute(true)]
        public virtual bool IsDelayedDiscon
        {
            get
            {
                return this._isDelayedDiscon;
            }
            set
            {
                if ((this._isDelayedDiscon != value))
                {
                    bool old = this._isDelayedDiscon;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnIsDelayedDisconChanging(e);
                    this.OnPropertyChanging("IsDelayedDiscon", e, _isDelayedDisconAttribute);
                    this._isDelayedDiscon = value;
                    this.OnIsDelayedDisconChanged(e);
                    this.OnPropertyChanged("IsDelayedDiscon", e, _isDelayedDisconAttribute);
                }
            }
        }
        
        /// <summary>
        /// The isLocalAutoReconOp property
        /// </summary>
        [XmlElementNameAttribute("isLocalAutoReconOp")]
        [XmlAttributeAttribute(true)]
        public virtual bool IsLocalAutoReconOp
        {
            get
            {
                return this._isLocalAutoReconOp;
            }
            set
            {
                if ((this._isLocalAutoReconOp != value))
                {
                    bool old = this._isLocalAutoReconOp;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnIsLocalAutoReconOpChanging(e);
                    this.OnPropertyChanging("IsLocalAutoReconOp", e, _isLocalAutoReconOpAttribute);
                    this._isLocalAutoReconOp = value;
                    this.OnIsLocalAutoReconOpChanged(e);
                    this.OnPropertyChanged("IsLocalAutoReconOp", e, _isLocalAutoReconOpAttribute);
                }
            }
        }
        
        /// <summary>
        /// The isLocalAutoDisconOp property
        /// </summary>
        [XmlElementNameAttribute("isLocalAutoDisconOp")]
        [XmlAttributeAttribute(true)]
        public virtual bool IsLocalAutoDisconOp
        {
            get
            {
                return this._isLocalAutoDisconOp;
            }
            set
            {
                if ((this._isLocalAutoDisconOp != value))
                {
                    bool old = this._isLocalAutoDisconOp;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnIsLocalAutoDisconOpChanging(e);
                    this.OnPropertyChanging("IsLocalAutoDisconOp", e, _isLocalAutoDisconOpAttribute);
                    this._isLocalAutoDisconOp = value;
                    this.OnIsLocalAutoDisconOpChanged(e);
                    this.OnPropertyChanged("IsLocalAutoDisconOp", e, _isLocalAutoDisconOpAttribute);
                }
            }
        }
        
        /// <summary>
        /// The isConnected property
        /// </summary>
        [XmlElementNameAttribute("isConnected")]
        [XmlAttributeAttribute(true)]
        public virtual bool IsConnected
        {
            get
            {
                return this._isConnected;
            }
            set
            {
                if ((this._isConnected != value))
                {
                    bool old = this._isConnected;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnIsConnectedChanging(e);
                    this.OnPropertyChanging("IsConnected", e, _isConnectedAttribute);
                    this._isConnected = value;
                    this.OnIsConnectedChanged(e);
                    this.OnPropertyChanged("IsConnected", e, _isConnectedAttribute);
                }
            }
        }
        
        /// <summary>
        /// The isRemoteAutoDisconOp property
        /// </summary>
        [XmlElementNameAttribute("isRemoteAutoDisconOp")]
        [XmlAttributeAttribute(true)]
        public virtual bool IsRemoteAutoDisconOp
        {
            get
            {
                return this._isRemoteAutoDisconOp;
            }
            set
            {
                if ((this._isRemoteAutoDisconOp != value))
                {
                    bool old = this._isRemoteAutoDisconOp;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnIsRemoteAutoDisconOpChanging(e);
                    this.OnPropertyChanging("IsRemoteAutoDisconOp", e, _isRemoteAutoDisconOpAttribute);
                    this._isRemoteAutoDisconOp = value;
                    this.OnIsRemoteAutoDisconOpChanged(e);
                    this.OnPropertyChanged("IsRemoteAutoDisconOp", e, _isRemoteAutoDisconOpAttribute);
                }
            }
        }
        
        /// <summary>
        /// The eventCount property
        /// </summary>
        [XmlElementNameAttribute("eventCount")]
        [XmlAttributeAttribute(true)]
        public virtual int EventCount
        {
            get
            {
                return this._eventCount;
            }
            set
            {
                if ((this._eventCount != value))
                {
                    int old = this._eventCount;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnEventCountChanging(e);
                    this.OnPropertyChanging("EventCount", e, _eventCountAttribute);
                    this._eventCount = value;
                    this.OnEventCountChanged(e);
                    this.OnPropertyChanged("EventCount", e, _eventCountAttribute);
                }
            }
        }
        
        /// <summary>
        /// The isRemoteAutoReconOp property
        /// </summary>
        [XmlElementNameAttribute("isRemoteAutoReconOp")]
        [XmlAttributeAttribute(true)]
        public virtual bool IsRemoteAutoReconOp
        {
            get
            {
                return this._isRemoteAutoReconOp;
            }
            set
            {
                if ((this._isRemoteAutoReconOp != value))
                {
                    bool old = this._isRemoteAutoReconOp;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnIsRemoteAutoReconOpChanging(e);
                    this.OnPropertyChanging("IsRemoteAutoReconOp", e, _isRemoteAutoReconOpAttribute);
                    this._isRemoteAutoReconOp = value;
                    this.OnIsRemoteAutoReconOpChanged(e);
                    this.OnPropertyChanged("IsRemoteAutoReconOp", e, _isRemoteAutoReconOpAttribute);
                }
            }
        }
        
        /// <summary>
        /// The Switches property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ConnectDisconnectFunctions")]
        [ConstantAttribute()]
        public virtual IOrderedSetExpression<ISwitch> Switches
        {
            get
            {
                return this._switches;
            }
        }
        
        /// <summary>
        /// The rcdInfo property
        /// </summary>
        [XmlElementNameAttribute("rcdInfo")]
        [XmlAttributeAttribute(true)]
        public virtual IRemoteConnectDisconnectInfo RcdInfo
        {
            get
            {
                return this._rcdInfo;
            }
            set
            {
                if ((this._rcdInfo != value))
                {
                    IRemoteConnectDisconnectInfo old = this._rcdInfo;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnRcdInfoChanging(e);
                    this.OnPropertyChanging("RcdInfo", e, _rcdInfoReference);
                    this._rcdInfo = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetRcdInfo;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetRcdInfo;
                    }
                    this.OnRcdInfoChanged(e);
                    this.OnPropertyChanged("RcdInfo", e, _rcdInfoReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ConnectDisconnectFunctionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("http://iec.ch/TC57/2009/CIM-schema-cim14#//IEC61968/LoadControl/ConnectDisconnect" +
                            "Function")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets fired before the IsDelayedDiscon property changes its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsDelayedDisconChanging;
        
        /// <summary>
        /// Gets fired when the IsDelayedDiscon property changed its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsDelayedDisconChanged;
        
        /// <summary>
        /// Gets fired before the IsLocalAutoReconOp property changes its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsLocalAutoReconOpChanging;
        
        /// <summary>
        /// Gets fired when the IsLocalAutoReconOp property changed its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsLocalAutoReconOpChanged;
        
        /// <summary>
        /// Gets fired before the IsLocalAutoDisconOp property changes its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsLocalAutoDisconOpChanging;
        
        /// <summary>
        /// Gets fired when the IsLocalAutoDisconOp property changed its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsLocalAutoDisconOpChanged;
        
        /// <summary>
        /// Gets fired before the IsConnected property changes its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsConnectedChanging;
        
        /// <summary>
        /// Gets fired when the IsConnected property changed its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsConnectedChanged;
        
        /// <summary>
        /// Gets fired before the IsRemoteAutoDisconOp property changes its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsRemoteAutoDisconOpChanging;
        
        /// <summary>
        /// Gets fired when the IsRemoteAutoDisconOp property changed its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsRemoteAutoDisconOpChanged;
        
        /// <summary>
        /// Gets fired before the EventCount property changes its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> EventCountChanging;
        
        /// <summary>
        /// Gets fired when the EventCount property changed its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> EventCountChanged;
        
        /// <summary>
        /// Gets fired before the IsRemoteAutoReconOp property changes its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsRemoteAutoReconOpChanging;
        
        /// <summary>
        /// Gets fired when the IsRemoteAutoReconOp property changed its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> IsRemoteAutoReconOpChanged;
        
        /// <summary>
        /// Gets fired before the RcdInfo property changes its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> RcdInfoChanging;
        
        /// <summary>
        /// Gets fired when the RcdInfo property changed its value
        /// </summary>
        public event System.EventHandler<ValueChangedEventArgs> RcdInfoChanged;
        
        private static ITypedElement RetrieveIsDelayedDisconAttribute()
        {
            return ((ITypedElement)(((ModelElement)(ConnectDisconnectFunction.ClassInstance)).Resolve("isDelayedDiscon")));
        }
        
        /// <summary>
        /// Raises the IsDelayedDisconChanging event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsDelayedDisconChanging(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsDelayedDisconChanging;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        /// <summary>
        /// Raises the IsDelayedDisconChanged event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsDelayedDisconChanged(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsDelayedDisconChanged;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        private static ITypedElement RetrieveIsLocalAutoReconOpAttribute()
        {
            return ((ITypedElement)(((ModelElement)(ConnectDisconnectFunction.ClassInstance)).Resolve("isLocalAutoReconOp")));
        }
        
        /// <summary>
        /// Raises the IsLocalAutoReconOpChanging event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsLocalAutoReconOpChanging(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsLocalAutoReconOpChanging;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        /// <summary>
        /// Raises the IsLocalAutoReconOpChanged event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsLocalAutoReconOpChanged(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsLocalAutoReconOpChanged;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        private static ITypedElement RetrieveIsLocalAutoDisconOpAttribute()
        {
            return ((ITypedElement)(((ModelElement)(ConnectDisconnectFunction.ClassInstance)).Resolve("isLocalAutoDisconOp")));
        }
        
        /// <summary>
        /// Raises the IsLocalAutoDisconOpChanging event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsLocalAutoDisconOpChanging(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsLocalAutoDisconOpChanging;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        /// <summary>
        /// Raises the IsLocalAutoDisconOpChanged event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsLocalAutoDisconOpChanged(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsLocalAutoDisconOpChanged;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        private static ITypedElement RetrieveIsConnectedAttribute()
        {
            return ((ITypedElement)(((ModelElement)(ConnectDisconnectFunction.ClassInstance)).Resolve("isConnected")));
        }
        
        /// <summary>
        /// Raises the IsConnectedChanging event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsConnectedChanging(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsConnectedChanging;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        /// <summary>
        /// Raises the IsConnectedChanged event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsConnectedChanged(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsConnectedChanged;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        private static ITypedElement RetrieveIsRemoteAutoDisconOpAttribute()
        {
            return ((ITypedElement)(((ModelElement)(ConnectDisconnectFunction.ClassInstance)).Resolve("isRemoteAutoDisconOp")));
        }
        
        /// <summary>
        /// Raises the IsRemoteAutoDisconOpChanging event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsRemoteAutoDisconOpChanging(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsRemoteAutoDisconOpChanging;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        /// <summary>
        /// Raises the IsRemoteAutoDisconOpChanged event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsRemoteAutoDisconOpChanged(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsRemoteAutoDisconOpChanged;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        private static ITypedElement RetrieveEventCountAttribute()
        {
            return ((ITypedElement)(((ModelElement)(ConnectDisconnectFunction.ClassInstance)).Resolve("eventCount")));
        }
        
        /// <summary>
        /// Raises the EventCountChanging event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnEventCountChanging(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.EventCountChanging;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        /// <summary>
        /// Raises the EventCountChanged event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnEventCountChanged(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.EventCountChanged;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        private static ITypedElement RetrieveIsRemoteAutoReconOpAttribute()
        {
            return ((ITypedElement)(((ModelElement)(ConnectDisconnectFunction.ClassInstance)).Resolve("isRemoteAutoReconOp")));
        }
        
        /// <summary>
        /// Raises the IsRemoteAutoReconOpChanging event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsRemoteAutoReconOpChanging(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsRemoteAutoReconOpChanging;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        /// <summary>
        /// Raises the IsRemoteAutoReconOpChanged event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnIsRemoteAutoReconOpChanged(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.IsRemoteAutoReconOpChanged;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        private static ITypedElement RetrieveSwitchesReference()
        {
            return ((ITypedElement)(((ModelElement)(ConnectDisconnectFunction.ClassInstance)).Resolve("Switches")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Switches property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SwitchesCollectionChanging(object sender, NMF.Collections.ObjectModel.NotifyCollectionChangingEventArgs e)
        {
            this.OnCollectionChanging("Switches", e, _switchesReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Switches property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SwitchesCollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Switches", e, _switchesReference);
        }
        
        private static ITypedElement RetrieveRcdInfoReference()
        {
            return ((ITypedElement)(((ModelElement)(ConnectDisconnectFunction.ClassInstance)).Resolve("rcdInfo")));
        }
        
        /// <summary>
        /// Raises the RcdInfoChanging event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnRcdInfoChanging(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.RcdInfoChanging;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        /// <summary>
        /// Raises the RcdInfoChanged event
        /// </summary>
        /// <param name="eventArgs">The event data</param>
        protected virtual void OnRcdInfoChanged(ValueChangedEventArgs eventArgs)
        {
            System.EventHandler<ValueChangedEventArgs> handler = this.RcdInfoChanged;
            if ((handler != null))
            {
                handler.Invoke(this, eventArgs);
            }
        }
        
        /// <summary>
        /// Handles the event that the RcdInfo property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetRcdInfo(object sender, System.EventArgs eventArgs)
        {
            this.RcdInfo = null;
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISDELAYEDDISCON"))
            {
                return this.IsDelayedDiscon;
            }
            if ((attribute == "ISLOCALAUTORECONOP"))
            {
                return this.IsLocalAutoReconOp;
            }
            if ((attribute == "ISLOCALAUTODISCONOP"))
            {
                return this.IsLocalAutoDisconOp;
            }
            if ((attribute == "ISCONNECTED"))
            {
                return this.IsConnected;
            }
            if ((attribute == "ISREMOTEAUTODISCONOP"))
            {
                return this.IsRemoteAutoDisconOp;
            }
            if ((attribute == "EVENTCOUNT"))
            {
                return this.EventCount;
            }
            if ((attribute == "ISREMOTEAUTORECONOP"))
            {
                return this.IsRemoteAutoReconOp;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "SWITCHES"))
            {
                return this._switches;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "RCDINFO"))
            {
                this.RcdInfo = ((IRemoteConnectDisconnectInfo)(value));
                return;
            }
            if ((feature == "ISDELAYEDDISCON"))
            {
                this.IsDelayedDiscon = ((bool)(value));
                return;
            }
            if ((feature == "ISLOCALAUTORECONOP"))
            {
                this.IsLocalAutoReconOp = ((bool)(value));
                return;
            }
            if ((feature == "ISLOCALAUTODISCONOP"))
            {
                this.IsLocalAutoDisconOp = ((bool)(value));
                return;
            }
            if ((feature == "ISCONNECTED"))
            {
                this.IsConnected = ((bool)(value));
                return;
            }
            if ((feature == "ISREMOTEAUTODISCONOP"))
            {
                this.IsRemoteAutoDisconOp = ((bool)(value));
                return;
            }
            if ((feature == "EVENTCOUNT"))
            {
                this.EventCount = ((int)(value));
                return;
            }
            if ((feature == "ISREMOTEAUTORECONOP"))
            {
                this.IsRemoteAutoReconOp = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "RcdInfo"))
            {
                return new RcdInfoProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "RcdInfo"))
            {
                return new RcdInfoProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("http://iec.ch/TC57/2009/CIM-schema-cim14#//IEC61968/LoadControl/ConnectDisconnect" +
                        "Function")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ConnectDisconnectFunction class
        /// </summary>
        public class ConnectDisconnectFunctionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ConnectDisconnectFunction _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ConnectDisconnectFunctionReferencedElementsCollection(ConnectDisconnectFunction parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Switches.Count);
                    if ((this._parent.RcdInfo != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.Switches.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.RcdInfoChanged += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.Switches.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.RcdInfoChanged -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ISwitch switchesCasted = item.As<ISwitch>();
                if ((switchesCasted != null))
                {
                    this._parent.Switches.Add(switchesCasted);
                }
                if ((this._parent.RcdInfo == null))
                {
                    IRemoteConnectDisconnectInfo rcdInfoCasted = item.As<IRemoteConnectDisconnectInfo>();
                    if ((rcdInfoCasted != null))
                    {
                        this._parent.RcdInfo = rcdInfoCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Switches.Clear();
                this._parent.RcdInfo = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Switches.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.RcdInfo))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> switchesEnumerator = this._parent.Switches.GetEnumerator();
                try
                {
                    for (
                    ; switchesEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = switchesEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    switchesEnumerator.Dispose();
                }
                if ((this._parent.RcdInfo != null))
                {
                    array[arrayIndex] = this._parent.RcdInfo;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ISwitch switchItem = item.As<ISwitch>();
                if (((switchItem != null) 
                            && this._parent.Switches.Remove(switchItem)))
                {
                    return true;
                }
                if ((this._parent.RcdInfo == item))
                {
                    this._parent.RcdInfo = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Switches).Concat(this._parent.RcdInfo).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isDelayedDiscon property
        /// </summary>
        private sealed class IsDelayedDisconProxy : ModelPropertyChange<IConnectDisconnectFunction, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsDelayedDisconProxy(IConnectDisconnectFunction modelElement) : 
                    base(modelElement, "isDelayedDiscon")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsDelayedDiscon;
                }
                set
                {
                    this.ModelElement.IsDelayedDiscon = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isLocalAutoReconOp property
        /// </summary>
        private sealed class IsLocalAutoReconOpProxy : ModelPropertyChange<IConnectDisconnectFunction, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsLocalAutoReconOpProxy(IConnectDisconnectFunction modelElement) : 
                    base(modelElement, "isLocalAutoReconOp")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsLocalAutoReconOp;
                }
                set
                {
                    this.ModelElement.IsLocalAutoReconOp = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isLocalAutoDisconOp property
        /// </summary>
        private sealed class IsLocalAutoDisconOpProxy : ModelPropertyChange<IConnectDisconnectFunction, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsLocalAutoDisconOpProxy(IConnectDisconnectFunction modelElement) : 
                    base(modelElement, "isLocalAutoDisconOp")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsLocalAutoDisconOp;
                }
                set
                {
                    this.ModelElement.IsLocalAutoDisconOp = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isConnected property
        /// </summary>
        private sealed class IsConnectedProxy : ModelPropertyChange<IConnectDisconnectFunction, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsConnectedProxy(IConnectDisconnectFunction modelElement) : 
                    base(modelElement, "isConnected")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsConnected;
                }
                set
                {
                    this.ModelElement.IsConnected = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isRemoteAutoDisconOp property
        /// </summary>
        private sealed class IsRemoteAutoDisconOpProxy : ModelPropertyChange<IConnectDisconnectFunction, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsRemoteAutoDisconOpProxy(IConnectDisconnectFunction modelElement) : 
                    base(modelElement, "isRemoteAutoDisconOp")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsRemoteAutoDisconOp;
                }
                set
                {
                    this.ModelElement.IsRemoteAutoDisconOp = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the eventCount property
        /// </summary>
        private sealed class EventCountProxy : ModelPropertyChange<IConnectDisconnectFunction, int>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public EventCountProxy(IConnectDisconnectFunction modelElement) : 
                    base(modelElement, "eventCount")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override int Value
            {
                get
                {
                    return this.ModelElement.EventCount;
                }
                set
                {
                    this.ModelElement.EventCount = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isRemoteAutoReconOp property
        /// </summary>
        private sealed class IsRemoteAutoReconOpProxy : ModelPropertyChange<IConnectDisconnectFunction, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsRemoteAutoReconOpProxy(IConnectDisconnectFunction modelElement) : 
                    base(modelElement, "isRemoteAutoReconOp")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsRemoteAutoReconOp;
                }
                set
                {
                    this.ModelElement.IsRemoteAutoReconOp = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the rcdInfo property
        /// </summary>
        private sealed class RcdInfoProxy : ModelPropertyChange<IConnectDisconnectFunction, IRemoteConnectDisconnectInfo>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public RcdInfoProxy(IConnectDisconnectFunction modelElement) : 
                    base(modelElement, "rcdInfo")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IRemoteConnectDisconnectInfo Value
            {
                get
                {
                    return this.ModelElement.RcdInfo;
                }
                set
                {
                    this.ModelElement.RcdInfo = value;
                }
            }
        }
    }
}

